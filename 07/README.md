# 第7章
・「算術」「メモリアクセス」に関するバイトコードをHACKアセンブリコードに変換する変換器を実装する  

### コンパイラの全体図
・バイトコードをHack機械語に変換する変換器を7章/8章で作成  
・高級水準言語(Jack)をバイトコードに変換するコンパイラを10章/11章で作成    
・「高級水準言語→バイトコード(コンパイラ)」）と「バイトコード→HACKアセンブリ言語(VM変換器)」と「HACKアセンブリ言語→HACK機械語（アセンブラ）」の3つは完全に独立  
・より正確には「バイトコードをHACK機械語に単純に変換する」というよりは、「HACKアーキテクチャ上で仮想レジスタ・仮想メモリセグメント・スタック構造をエミュレートすることで、バイトコードの実行環境をVMとして作成する」が正しい 

### 仮想マシンの分類
・Wikipediaによるとシステム仮想マシンとプロセス仮想マシンがある  
・プログラミング言語の実行環境としての仮想マシンはプロセス仮想マシンを指す  

### プロセス仮想マシンのメリット
・プロセス仮想マシンを利用する最大のメリットは移植性  　　
・ハードウェアのアーキテクチャに依存しなくなる＝「高級水準言語」と「機械語」の依存性の分離    

### 仮想マシンの実装方法 
・インタプリタ  
・専用ハードウェア  
・対象プラットフォームの機械語  

### プロセス仮想マシンの分類
・スタック仮想マシンとレジスタ仮想マシンの2種類ありそれぞれ一長一短  
・今回はJVMと同じくスタック仮想マシンを実装

### バイトコード
・「算術」「メモリアクセス」「プログラムフロー」「サブルーチン呼び出し」の4種  
・上記4種類のいずれにもスタック操作は明示的には現れていないことに注意！(=スタックの代わりにレジスタでも実装できる)  

### 仮想マシンの仕様
・算術コマンドとセグメント（仮想レジスタ）の仕様がP144およびP145に記載    
・これは事実上仮想マシンのアーキテクチャの仕様と同義  
・HACKアーキテクチャのレジスタ2個でレジスタ16個のレジスタをエミュレート  

### 標準マッピング
・VM変換器の実装において、プラットフォーム上でRAMの利用方法/レジスタの利用方法/セグメントの利用方法/シンボルの利用方法に関しては任意  
・それらの利用方法を「標準マッピング」として明確化  

### 標準マッピングに基づいたRAMの使用法
・0-15：仮想レジスタ  
・16-255：スタティック変数  
・265-2047：スタック  
・2048-16383：ヒープ  
・16384-24575：メモリマップドIO  
・24576-32767：使用しないメモリ領域  
    
### 標準マッピングに基づいた仮想レジスタの使用法
・RAM[0]：SP　スタックポインタ：スタック最上位の次を指す  
・RAM[1]：LCL　現在のVM関数におけるlocalアドレスのベースアドレス  
・RAM[2]：ARG　現在のVM関数内におけるargumentセグメントのベースアドレスを指す  
・RAM[3]：THIS　現在のヒープ内におけるthisセグメントのベースアドレスを指す  
・RAM[4]：THAT　現在のヒープ内におけるthatセグメントのベースアドレスを指す  
・RAM[5-12]：tempセグメントの値を保持  
・RAM[13-15]：汎用レジスタ    

### 注意
・pointerセグメントでthisとthatの違いは、対象が配列かオブジェクトかどうか  
・pop pointer 0 はthisレジスタ  
・pop pointer 1 はthatレジスタ  
・これ以降thisやthatにindexを指定（＝アドレスを直接指定）してpop/pushすることは、対象オブジェクトのアドレスを「直接」さしているので、対象オブジェクトの操作  
  
### 感想
・任意の高級水準言語のプログラム(算術命令・論理命令)をスタック操作に還元できるという事実に驚愕  
・JREや.NETフレームワークのライブラリはメモリ管理・GUI操作・文字列・数学関連のライブラリが揃っており小さなOSとみなせる  
・asm_code.pyでクラスメソッドを利用したのはちょっと微妙な気がする。もう少し綺麗な実装がありそう  